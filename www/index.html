<html>
<head>
<title>ci-bayes: Collective Intelligence' bayes ported to Java</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
</head>

<body bgcolor="#FFFFFF" text="#000000">

<h1>Bayesian Classifiers for Java</h1>  
<p>This project contains two bayesian classifiers for Java: a Naive
implementation and a Fishers implementation. It's merely a port from Toby
Segaran's <a href="classifier.py">python code for Bayesian analysis</a> from his book &quot;Programming Collective
Intelligence.&quot;</p>
 
 <p>The only requirement for this library is <a
href="http://javolution.org">javolution</a>. (Even this is debatable, but
     javolution is good enough it's worth depending on.  </p>
 
 <p>It's licensed under the Artistic License.</p>
  <h2>Usage</h2><p>Basically, using ci-bayes is a matter of defining a way to
extract elements from a body of text (an implementation of the WordLister
interface), and then constructing a Classifier.   
<p>A default naive WordListerImpl is supplied with the library.  </p>
<p>A simple example of the NaiveClassifier in use might look like this:</p>
<pre>FisherClassifier fc=new FisherClassifierImpl();
fc.train(&quot;The quick brown fox jumps over the lazy dog's tail&quot;,&quot;good&quot;);
fc.train(&quot;Make money fast!&quot;, &quot;bad&quot;); 
String classification=fc.getClassification(&quot;money&quot;); // should be &quot;bad&quot;</pre>

<p>There's also a Serializer class provided, which shows
how a given Classifier can be persisted (through Java Serialization, even.)
The class shows how any given classifier can be persisted.  
<p>Other storage mechanisms - like JDBC, JPA, XML, etc. - can be built as
well.</p>
<h2>WordLister Usage</h2>
<p>One of the keys to using the classifier is the provision of a WordLister. A word lister
returns a set of strings (<code>Set&lt;String&gt;)</code>from an object.</p>
<p>The default provided WordLister implementation is
    <code>com.<wbr />enigmastation.<wbr />classifier.<wbr />WordListerImpl</code>.
When <code>getUniqueWords()</code> is called, it calls <code>toString()</code> on the object passed to it,
    and it then splits the resulting string into individual words. It then strips out all short and long words
(meaning words less than three letters long and more than twenty letters long), converts them to lowercase,
then returns a set containing those words.</p>
<p>
    Any custom version of <code>WordLister</code> needs to follow the same process. However, since
    <code>WordLister.getUniqueWords</code> takes an <code>Object</code>, you can pass any custom datatype
    in that you like, parsing the string representation of the data type however you like.
</p>
<h2>Persisting The Classifiers</h2>
<p>It's not much use, having a bayesian classifier, if it can't use the dataset for more than one
classification. For this reason, the Classifier interface defines getCategoryFeatureMap and
    getCategoryDocCount, which provide low-level access to the underlying datastructures.</p>
    <p>It's expected that any persistence mechanism would use these functions to
        store the data structures. Remember that the data structures can (and probably will) become
    <b>very very large</b>, especially as they grow more useful (assuming the classic use of bayesian
    classification), so be aware that walking through the data structures, storing tuples, is likely to be
    unworkable.</p>

<h2>Listeners</h2>
<p>A classifier can have a ClassifierListener added to it, to receive events as the classifier processes them.
This is useful for cases where you might not want to manage the entire Classifier dataset as a monolithic
block of data (since a trained classifier can be many megabytes in size).

<p>There are currently two types of events that a ClassifierListener can handle: a feature update and a category
update. One might use this information to update a JDBC row, for example, that represents a piece of classifier
data. As yet, updates can not be vetoed. (If anyone can think of a reason you'd want to veto a feature or
category update, please chime in and it'll be added.)</p>

<h2>Tests</h2>
The classifier includes a corpus test, using the corpus from SpamAssassin as training and testing corpora.
As it stands right now, it has a 98% accuracy (compared to SpamAssassin) and runs the entire test in
11 seconds or so.

<p>Differences in accuracy really aren't as horrible as they might seem. For one thing, ci-bayes
    uses a different algorithm than SpamAssassin - in that it can manage multiple classifications
    (not just "ham" or "spam" as SA does) and it also uses Naive and Fishers algorithms - I'm not
sure exactly which algorithms SpamAssassin uses. So: differences are okay, as long as they're not
HUGE differences.</p>
</body>
</html>

